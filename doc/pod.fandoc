Overview [#overview]
********************
'efanXtra' creates managed libraries of reusable [Embedded Fantom (efan)]`http://www.fantomfactory.org/pods/afEfan`
components. Influenced by Java's [Tapestry 5]`http://tapestry.apache.org/index.html`, it pairs up Fantom classes and efan template
files to encapsulate model / view behaviour.

'efanXtra' extends [afEfan]`http://www.fantomfactory.org/pods/afEfan`, is powered by
[Ioc]`http://www.fantomfactory.org/pods/afIoc` and works great with [Slim]`http://www.fantomfactory.org/pods/afSlim`
templates.

'efanXtra' excels in a [BedSheet]`http://www.fantomfactory.org/pods/afBedSheet` web environment, where URLs are
automatically mapped to efan components (see [Pillow]`http://www.fantomfactory.org/pods/afPillow`), but is presented
here context free for maximum reuse. Think email, code generation, blog posts, etc...



Quick Start [#quickStart]
*************************
Overdue.efan:
pre>
Dear <%= userName %>,

It appears the following rented DVDs are overdue:

    <%= dvds.join(", ") %>

Please return them at your convenience.

<% app.renderSignOff("The Management") %>
<pre

Overdue.fan:
pre>
using afIoc
using afEfanXtra

const mixin Overdue : EfanComponent {

  // use afIoc services!
  @Inject
  abstract DvdService? dvdService

  // mixin fields can be accessed by the template
  abstract Str? userName

  // use lifecycle methods to initialise your components
  @InitRender
  Void initRender(Str userName) {
    this.userName = userName
  }

  // mixin methods can be called from the template
  Str[] dvds() {
    dvdService.findByName(userName)
  }
}
<pre

AppModule.fan:
pre>
using afIoc

class AppModule {

  static Void bind(ServiceBinder binder) {
    binder.bindImpl(DvdService#)
  }

  @Contribute { serviceType=EfanLibraries# }
  static Void contributeEfanLibraries(MappedConfig config) {

    // contribute all components in the pod as a library named 'app'
    config["app"] = AppModule#.pod
  }
}
<pre

Then to render an efan component:

  efanXtra.render(Overdue#, "Mr Smith")

Full example source code available on [BitBucket]`https://bitbucket.org/AlienFactory/afefanxtra/src/default/test/example/`.



Components [#components]
************************
An efan component consists of a 'const mixin' Fantom class and a corresponding efan template file.

'efanXtra' does away with [efan's]`http://www.fantomfactory.org/pods/afEfan` 'ctx' variable and instead lets the template
access fields and methods of the component class directly.

Mixins [#mixins]
================
Component mixins must be 'const' and extend the `EfanComponent` mixin.

All fields and methods of the mixin are directly accessible in the template. Components are created by
[Ioc]`http://www.fantomfactory.org/pods/afIoc` so feel free to annotate fields with '@Inject' just as you would with
a service class.

Any non-private method or field in your mixin is visible from your template code.

See [Lifecycle Methods]`#lifecycle` to see how to initialise and pass data into your components.

Templates [#templates]
======================
By default, the template file has the same name as the component (with a '.efan' extension) and lives anywhere in a pod
resource dir. For example, if you were to create a component called 'Layout', you may have the following files:

  /fan/components/Layout.fan  --> the mixin class
  /fan/components/Layout.efan --> the template file

For 'efanXtra' to find your template file, be sure to add '/fan/components/' as a 'resDir' in your 'build.fan'.

> **ALIEN-AID:** Note resource directories in your 'build.fan' are NOT nested. Adding 'res/' will NOT add
> '/res/components/' - '/res/components/' needs to be added separately. Example:

  resDirs = [`doc/`, `res/`, `res/components/`]

You can also contribute to `EfanTemplateDirectories` if you wish to keep template files on the file system. This can be very handy
for development.

If you wish the template to have a different name to the Fantom class, you can set an explicit 'Uri' with the
[@EfanTemplate]`EfanTemplate` facet. Example:

pre>
  @EfanTemplate { uri=`fan://acmePod/templates/Notice.efan` }
  const mixin Overdue : EfanComponent {
    ...
  }
<pre



Libraries [#libraries]
**********************
Components are organised by libraries. A library encompasses all components within a pod.
To use your efan components, you need add your pod as a library. Do this in your 'AppModule':

pre>
using afIoc
using afEfanXtra

class AppModule {

  @Contribute { serviceType=EfanLibraries# }
  static Void contributeEfanLibraries(MappedConfig config) {

    // contribute all components in the same pod as AppModule, as a library called 'app'
    config["app"] = AppModule#.pod
  }
}
<pre

Library classes are automatically added as fields in your components. Library classes contain component render methods.
In the [Overview]`#overview` example, the library (in a field named 'app') would bave 2 render methods, available for use in
your templates:

   app.renderOverdue(Str userName)
   app.renderSignOff(Str who)

This allows you to render components from within templates by calling '<libName>.render<ComponentName>(...)'. Example:

  <% app.renderSignOff("The Management") %>

> **ALIEN-AID:** Library render methods are logged at registry startup so you don't have to remember the method signatures!



Lifecycle Methods [#lifecycle]
******************************

Components can be thought of as having a lifecycle for the duration of their render.
Components can be made aware of the lifecycle by annotating callback methods with lifecycle facets.
The lifecycle only exists for the duration of the render.

![efanXtra Component Lifecycle]`http://static.alienfactory.co.uk/fantom-docs/lifecycle.png`

@InitRender [#initRender]
=========================
A method annotated with [@InitRender]`InitRender` will be called before any other. It allows you to initialise and prepare
your component for rendering.

The '@InitRender' may take any parameters, the signature will be mimicked by the containing library's render method. Example,
if your '@InitRender' looks like:

  const mixin MyComponent : EfanComponent {

    @InitRender
    Bool? initRender(Int x, Str y) { ... }

  }

then the library render method will look like:

  Obj? renderMyComponent(Int x, Str y, |->| bodyFunc := null) { ... }

This lets you pass any arguments you want into your components.

'@InitRender' methods may return 'Bool'. If 'true', the template is rendered as usual. If 'false', then template rendering is skipped.

@BeforeRender [#beforeRender]
=============================
A method annotated with [@BeforeRender]`BeforeRender` is invoked after '@InitRender' but before any template rendering. It may
optionally take a 'StrBuf' as a parameter, this will hold the contents of the current render buffer.

'@BeforeRender' methods may return 'Bool'. If 'true', the template is rendered as usual. If 'false', then template rendering is skipped.

@AfterRender [#afterRender]
===========================
A method annotated with [@AfterRender]`AfterRender` is invoked after the template has rendered. It may
optionally take a 'StrBuf' as a parameter, this will hold the contents of the current render buffer.

'@AfterRender' methods may return 'Bool'. If 'true', the template rendering ends. If 'false', template rendering is sent back
to '@BeforeRender'. In this way, simple loops may be set up.



Render Variables [#renderVariables]
***********************************
Efan components can store state! Components may be 'const' and they may be 'mixins', but they can still store variables that
can be accessed and used by the rendering template. Taking the [Overdue]`#overview` component as an example:

pre>
using afEfanXtra

const mixin Overdue : EfanComponent {

  abstract Str? userName

  @InitRender
  Void initRender(Str userName) {
    this.userName = userName
  }
}
<pre

'userName' is a render variable used by the efan template. Before 'initRender()' is called, all render variables are reset to 'null'
(hence they need to be 'nullable'). They may then be initialised during 'initRender()', and used and / or reset at any other point
in the rendering lifecycle.

Note that state is *not* preserved between different renderings of the component.



Use with Slim [#useSlim]
************************
'efanXtra' works great with [Slim]`http://www.fantomfactory.org/pods/afSlim`! Just add the following to your 'AppModule'
and 'efanXtra' will automatically pick up component templates with the extension '.slim':

pre>
using afIoc
using afSlim
using afEfanXtra

class AppModule {

  static Void bind(ServiceBinder binder) {
    binder.bindImpl(Slim#)
  }

  @Contribute { serviceType=EfanTemplateConverters# }
  internal static Void contributeSlimTemplates(MappedConfig config, Slim slim) {
    config["slim"] = |File file -> Str| { slim.parseFromFile(file) }
  }
}
<pre



Release Notes [#releaseNotes]
*****************************
v1.0.12 [#v1.0.12]
------------------
 - Chg: Components can now have threaded services injected into them!

v1.0.10 [#v1.0.10]
------------------
 - New: Added 'EfanLibraries.callMethod()' for [Pillow]`http://www.fantomfactory.org/pods/afPillow`.
 - Chg: Components automatically 'use' the pod that the component mixin was defined in.
 - Chg: 'ComponentCompiler' callbacks now take the component type.
 - Chg: 'FindEfanByFacetValue' is public for use by [Pillow]`http://www.fantomfactory.org/pods/afPillow`.
 - Chg: Render methods are searched for on the component *instance*, not just the mixin. This is so it may still be called if it's added dynamically.

v1.0.8 [#v1.0.8]
----------------
 - New: 'fandoc' files may be used as efan templates!

v1.0.6 [#v1.0.6]
----------------
 - Chg: Upgraded to [afIoc-1.5.0]`http://www.fantomfactory.org/pods/afIoc`.
 - Chg: Upgraded to [afIocConfig-1.0.0]`http://www.fantomfactory.org/pods/afIocConfig`.

v1.0.4 [#v1.0.4]
----------------
 - Chg: '@InitMethods' may now only return 'Void' or 'Bool'. Throw
 [BedSheet's]`http://www.fantomfactory.org/pods/afBedSheet` 'ReProcessErr' if you wish to perform a different action.
 - Chg: Multiple components may now share the same template file.

v1.0.2 [#v1.0.2]
----------------
 - Chg: Overhauled API documentation.
 - Chg: Tweaked some method signatures with correct nullable types.

v1.0.0 [#v1.0.0]
----------------
 - New: Introduced component lifecycle methods: [@InitRender]`InitRender`, [@BeforeRender]`BeforeRender`
   & [AfterRender]`AfterRender`.
 - New: Added '@Abstract' facet to mark base components.
 - Chg: Template rendering is held in a single mutable 'StrBuf' so it may be manipulated by lifecycle methods.
 - Chg: Components are now defined by extending 'EfanComponent', not by annotating with a '@Component' facet.
 - Chg: Renamed to 'efanXtra' (from 'efanExtra').

v0.0.8 [#v0.0.8]
----------------
 - New: Added 'EfanTemplateDirectories' service which scans external directories for efan templates.
 - New: Compilation err msgs are updated with code hints should a simple component rendering typo be spotted. (ALIEN-AID)

v0.0.6 [#v0.0.6]
----------------
 - New: Fields may be annotated with *any* facet, not just '@Inject'. Think '@Config'!!!
 - Chg: Updated to efan-1.3.2
 - Chg: Better Err msgs if component template not found.

v0.0.4 [#v0.0.4]
----------------
 - New: Component templates can be specified via the '@Component.template' field.
 - New: Added a contributable 'EfanTemplateFinders' service.
 - New: Ability to suppress startup log messages.
 - New: Added compiler hooks (mainly for [afPillow]`http://www.fantomfactory.org/pods/afPillow`).
 - New: 'efanXtra.component()' returns component instances.
 - Chg: '@Component' facet is inherited.

v0.0.2 [#v0.0.2]
----------------
 - New: Preview Release

